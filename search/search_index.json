{"config":{"lang":["it"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Census Istat","text":"<p>Con census_istat puoi ottenere facilmente il set di dati riferiti ai censimenti ISTAT in cui sono stati rilasciati anche i dati delle celle censuarie.</p> <p>Note</p> <p>Ad oggi i dati censuari ufficiali sono riferiti agli anni 1991, 2001 e 2011. Il 2 febbraio 2023 ISTAT ha pubblicato una nota in cui indica che i dati del censimento 2021 verranno pubblicati entro il primo semestre 2023.</p> <p>I dati dei censimenti della popolazione a cadenza decennale si differiscono da quelli del censimento permanente. I dati del censimento permanente sono riferiti ad un campione della popolazione italiana,  mentre quelli del censimento decennale sono a carattere puntuale.</p> <p>Per la descrizione dei dati dal 1991 al 2011 si \u00e8 fatto riferimento alla documentazione ufficiale.</p> <p>Info</p> <p>Questo progetto non \u00e8 collegato ad ISTAT n\u00e8 supportato da ISTAT.</p> <p>Questo repository \u00e8 stato creato grazie a MkDocs, Material for MkDocs e mkdocstring.</p>"},{"location":"LICENSE/","title":"Licenza","text":"<p>MIT License</p> <p>Copyright (c) 2023 Massimiliano Moraca</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"documentation/data/","title":"Modulo Dati","text":"<p>I dati censuari risultano essere differenti tra anno ed anno non solo per il loro contenuto ma anche per la struttura dati con cui sono stati condivisi. In particolare gli anni 1991 e 2001 risultano avere una struttura dati uguale, mentre nel 2011 si ha una struttura totalmente differente. Si \u00e8 scelto dunque di normalizzare i dati 1991-2001 secondo la struttura dati del 2011 perch\u00e8 per questo anno abbiamo i dati censuari pubblicati come <code>csv</code>, formato file pi\u00f9 adatto alla condivisione dei dati rispetto a <code>xls</code>.</p>"},{"location":"documentation/data/#anni-1991-2001","title":"Anni 1991-2001","text":""},{"location":"documentation/data/#census_istat.data.census_1991_2001.census_trace","title":"<code>census_trace(file_path, year, output_path)</code>","text":"<p>Creazione del file di tracciato per gli anni 1991 e 2001.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>Union[Path, PosixPath]</code> <p>Union[Path, PosixPath]</p> required <code>year</code> <code>int</code> <p>int</p> required <code>output_path</code> <code>Union[Path, PosixPath]</code> <p>Union[Path, PosixPath]</p> required <p>Returns:</p> Type Description <code>Union[Path, PosixPath]</code> <p>Union[Path, PosixPath]</p> Source code in <code>census_istat/data/census_1991_2001.py</code> <pre><code>def census_trace(\n        file_path: Union[Path, PosixPath],\n        year: int,\n        output_path: Union[Path, PosixPath],\n) -&gt; Union[Path, PosixPath]:\n\"\"\"Creazione del file di tracciato per gli anni 1991 e 2001.\n\n    Args:\n        file_path: Union[Path, PosixPath]\n        year: int\n        output_path: Union[Path, PosixPath]\n\n    Returns:\n        Union[Path, PosixPath]\n    \"\"\"\n    logging.info(f'Read data from {file_path}')\n    read_data = xlrd.open_workbook(file_path)\n\n    get_sheet = read_data.sheet_by_name('Metadati')\n\n    dataset = []\n    for row_id in range(get_sheet.nrows):\n        dataset.append(get_sheet.row_values(row_id)[:2])\n    dataset = dataset[7:]\n\n    # Make DataFrame columns\n    df_columns = [column_name for column_name in dataset[0]]\n\n    # Make DataFrame data\n    df_data = dataset[1:]\n\n    df = pd.DataFrame(data=df_data, columns=df_columns)\n    df.set_index('NOME CAMPO', inplace=True)\n\n    file_name = f'tracciato_{year}_sezioni.csv'\n    logging.info(f\"Save data to {output_path.joinpath(file_name)}\")\n    df.to_csv(output_path.joinpath(file_name))\n</code></pre>"},{"location":"documentation/data/#census_istat.data.census_1991_2001.compare_dataframe","title":"<code>compare_dataframe(data)</code>","text":"<p>Comparazione dell'intestazione dei dati censuari per definirne le differenze.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>list</code> <p>list</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame</p> Source code in <code>census_istat/data/census_1991_2001.py</code> <pre><code>def compare_dataframe(data: list) -&gt; DataFrame:\n\"\"\"Comparazione dell'intestazione dei dati censuari per definirne le differenze.\n\n    Args:\n        data: list\n\n    Returns:\n        DataFrame\n    \"\"\"\n\n    df_list = []\n    for file_data in data:\n\n        df_csv = pd.read_csv(file_data)\n        df_csv = df_csv.iloc[7:, 0:2]\n        df_csv.rename(columns={'Unnamed: 0': 'nome_campo', 'Unnamed: 1': 'definizione'}, inplace=True)\n        df_csv.set_index('nome_campo', inplace=True)\n\n        name_csv = ['id', file_data.stem]\n\n        df_csv_name = pd.DataFrame([name_csv], columns=['nome_campo', 'definizione'])\n        df_csv_name.set_index('nome_campo', inplace=True)\n\n        data_df = pd.concat([df_csv, df_csv_name])\n\n        data_df_t = data_df.transpose()\n        data_df_t.set_index('id', inplace=True)\n        data_df_t.columns = data_df_t.columns.str.lower()\n\n        df_list.append(data_df_t)\n\n    df = pd.concat(df_list)\n    df.sort_index(inplace=True)\n\n    return df\n</code></pre>"},{"location":"documentation/data/#census_istat.data.census_1991_2001.merge_data_1991_2001","title":"<code>merge_data_1991_2001(csv_path, year, separator=';', output_path=None)</code>","text":"<p>Generazione di un unico file con tutti i dati censuari dell'anno selezionato.</p> <p>Parameters:</p> Name Type Description Default <code>csv_path</code> <code>Union[Path, PosixPath]</code> <p>Union[Path, PosixPath]</p> required <code>year</code> <code>int</code> <p>int</p> required <code>separator</code> <code>str</code> <p>str</p> <code>';'</code> <code>output_path</code> <code>Union[Path, PosixPath]</code> <p>Union[Path, PosixPath]</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Path, PosixPath, DataFrame]</code> <p>Union[Path, PosixPath, DataFrame]</p> Source code in <code>census_istat/data/census_1991_2001.py</code> <pre><code>def merge_data_1991_2001(\n        csv_path: Union[Path, PosixPath],\n        year: int,\n        separator: str = ';',\n        output_path: Union[Path, PosixPath] = None,\n) -&gt; Union[Path, PosixPath, DataFrame]:\n\"\"\"Generazione di un unico file con tutti i dati censuari dell'anno selezionato.\n\n    Args:\n        csv_path: Union[Path, PosixPath]\n        year: int\n        separator: str\n        output_path: Union[Path, PosixPath]\n\n    Returns:\n        Union[Path, PosixPath, DataFrame]\n    \"\"\"\n    administrative_boundaries = csv_path.parent.parent.joinpath(BOUNDARIES_DATA_FOLDER)\n\n    if year == 1991:\n        municipality_path = administrative_boundaries.joinpath(f'Limiti{year}')\n    elif year == 2001:\n        municipality_path = administrative_boundaries.joinpath(f'Limiti{year}').joinpath(f'Limiti{year}')\n    else:\n        pass\n\n    target_data = list(municipality_path.rglob('*.xls'))\n\n    if len(target_data) &gt; 1:\n        raise Exception(f'Only one Excel file must be present in folder {municipality_path}')\n\n    # Get Municipality data\n    municipality_data = _merge_administrative_data(data_path=target_data[0], year=year)\n\n    # Get census data\n    census_data = merge_data(\n        csv_path=csv_path,\n        year=year,\n        separator=separator\n    )\n    # TODO Multithread processing with Dask #15\n    # # Dask DataFrame to Pandas DataFrame\n    # census_data = census_data.compute()\n\n    # Join all\n    join_data = pd.merge(\n        left=census_data,\n        right=municipality_data,\n        on='pro_com'\n    )\n    join_data.rename(columns={'cod_com': 'codcom'}, inplace=True)\n    join_data.drop(columns={'cod_pro', 'pro_com', 'sezione'}, inplace=True)\n\n    if output_path is None:\n        # Pandas DataFrame to Dask DataFrame\n        return join_data.from_pandas()\n\n    else:\n        output_data = output_path.joinpath(f'data{year}.csv')\n        logging.info(f'Save data to {output_data}')\n        join_data.to_csv(output_data, sep=separator, index=False)\n</code></pre>"},{"location":"documentation/data/#census_istat.data.census_1991_2001.preprocess_csv_1991_2001","title":"<code>preprocess_csv_1991_2001(census_year, output_path, census_data_folder)</code>","text":"<p>Processamento dei dati censuari per gli anni 1991 e 2001.</p> <p>Parameters:</p> Name Type Description Default <code>census_year</code> <code>int</code> <p>int</p> required <code>output_path</code> <code>Union[Path, PosixPath]</code> <p>Union[Path, PosixPath]</p> required <code>census_data_folder</code> <code>Union[Path, PosixPath]</code> <p>Union[Path, PosixPath]</p> required <p>Returns:</p> Type Description <code>Union[Path, PosixPath]</code> <p>Union[Path, PosixPath]</p> Source code in <code>census_istat/data/census_1991_2001.py</code> <pre><code>def preprocess_csv_1991_2001(\n        census_year: int,\n        output_path: Union[Path, PosixPath],\n        census_data_folder: Union[Path, PosixPath]\n) -&gt; Union[Path, PosixPath]:\n\"\"\"Processamento dei dati censuari per gli anni 1991 e 2001.\n\n    Args:\n        census_year: int\n        output_path: Union[Path, PosixPath]\n        census_data_folder: Union[Path, PosixPath]\n\n    Returns:\n        Union[Path, PosixPath]\n    \"\"\"\n    # Make preprocess folder\n    processing_folder = output_path.joinpath(PREPROCESSING_FOLDER)\n    Path(processing_folder).mkdir(parents=True, exist_ok=True)\n\n    # Read metadata\n    processing_file_list = get_metadata(input_path=census_data_folder, output_path=processing_folder)\n\n    # Compare DataFrame\n    df = compare_dataframe(data=processing_file_list)\n    df.to_csv(processing_folder.joinpath(f'check_metadata_{census_year}.csv'))\n</code></pre>"},{"location":"documentation/data/#census_istat.data.census_1991_2001.read_xls","title":"<code>read_xls(file_path, census_code='sez1991', output_path=None, metadata=False)</code>","text":"<p>Lettura dei dati censuari relativi agli anni 1991 e 2011 e costruzione di un DataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>Union[Path, PosixPath]</code> <p>Union[Path, PosixPath]</p> required <code>census_code</code> <code>str</code> <p>str</p> <code>'sez1991'</code> <code>output_path</code> <code>Union[Path, PosixPath]</code> <p>Union[Path, PosixPath]</p> <code>None</code> <code>metadata</code> <code>bool</code> <p>bool</p> <code>False</code> <p>Returns:</p> Type Description <code>Union[DataFrame, Path, PosixPath]</code> <p>Union[DataFrame, Path, PosixPath]</p> Source code in <code>census_istat/data/census_1991_2001.py</code> <pre><code>def read_xls(\n        file_path: Union[Path, PosixPath],\n        census_code: str = 'sez1991',\n        output_path: Union[Path, PosixPath] = None,\n        metadata: bool = False\n) -&gt; Union[DataFrame, Path, PosixPath]:\n\"\"\"Lettura dei dati censuari relativi agli anni 1991 e 2011\n    e costruzione di un DataFrame.\n\n    Args:\n        file_path: Union[Path, PosixPath]\n        census_code: str\n        output_path: Union[Path, PosixPath]\n        metadata: bool\n\n    Returns:\n        Union[DataFrame, Path, PosixPath]\n    \"\"\"\n    logging.info(f'Read data from {file_path}')\n    read_data = xlrd.open_workbook(file_path)\n\n    if metadata:\n        sheet_name = 'Metadati'\n    else:\n        sheet_list = read_data.sheet_names()\n        sheet_list.remove('Metadati')\n        sheet_name = sheet_list[0]\n\n    get_sheet = read_data.sheet_by_name(sheet_name)\n\n    dataset = []\n    for row_id in tqdm(range(get_sheet.nrows)):\n        dataset.append(get_sheet.row_values(row_id))\n\n    # Make DataFrame columns\n    df_columns = [column_name.lower() for column_name in dataset[0]]\n\n    # Make DataFrame data\n    df_data = dataset[1:]\n\n    # Make DataFrame\n    logging.info('Make DataFrame')\n    df = pd.DataFrame(data=df_data, columns=df_columns)\n    df = df.astype(int)\n    df.set_index(census_code, inplace=True)\n    df.sort_index(inplace=True)\n\n    if output_path is None:\n        return df\n\n    else:\n        file_name = file_path.stem.split('\\\\')[1]\n        logging.info(f\"Save data to {output_path.joinpath(f'{file_name}.csv')}\")\n        df.to_csv(path_or_buf=output_path.joinpath(f'{file_name}.csv'), sep=';')\n</code></pre>"},{"location":"documentation/data/#census_istat.data.census_1991_2001.remove_xls","title":"<code>remove_xls(folder_path, census_code, output_path)</code>","text":"<p>Eliminiazione di tutti i file Excel.</p> <p>Parameters:</p> Name Type Description Default <code>folder_path</code> <code>Union[Path, PosixPath]</code> <p>Union[Path, PosixPath]</p> required <code>census_code</code> <code>str</code> <p>str</p> required <code>output_path</code> <code>Union[Path, PosixPath]</code> <p>Union[Path, PosixPath]</p> required Source code in <code>census_istat/data/census_1991_2001.py</code> <pre><code>def remove_xls(\n        folder_path: Union[Path, PosixPath],\n        census_code: str,\n        output_path: Union[Path, PosixPath]\n) -&gt; None:\n\"\"\"Eliminiazione di tutti i file Excel.\n\n    Args:\n        folder_path: Union[Path, PosixPath]\n        census_code: str\n        output_path: Union[Path, PosixPath]\n    \"\"\"\n    files_path = list(folder_path.rglob(\"*.xls\"))\n\n    # Convert xls to csv\n    for file_path in files_path:\n        read_xls(\n            file_path=file_path,\n            census_code=census_code,\n            output_path=output_path\n        )\n\n    # Remove xls\n    for file_path in files_path:\n        os.remove(file_path)\n</code></pre>"},{"location":"documentation/data/#anno-2011","title":"Anno 2011","text":""},{"location":"documentation/data/#census_istat.data.manage_data.list_shared_columns","title":"<code>list_shared_columns()</code>","text":"<p>Generazione della lista di tutti i dati condivisi.</p> <p>Returns:</p> Type Description <code>list</code> <p>list</p> Source code in <code>census_istat/data/manage_data.py</code> <pre><code>def list_shared_columns() -&gt; list:\n\"\"\"Generazione della lista di tutti i dati condivisi.\n\n    Returns:\n        list\n    \"\"\"\n    column_list = []\n    for key, value in SHARED_DATA.items():\n        column_code = value['codice'].lower()\n        column_list.append(column_code)\n\n    return column_list\n</code></pre>"},{"location":"documentation/data/#census_istat.data.manage_data.merge_data","title":"<code>merge_data(csv_path, year, separator=';', output_path=None)</code>","text":"<p>Unione di tutti i dati censuari per l'anno selezionato in un unico DataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>csv_path</code> <code>Union[Path, PosixPath]</code> <p>Union[Path, PosixPath]</p> required <code>year</code> <code>int</code> <p>int</p> required <code>separator</code> <code>str</code> <p>str</p> <code>';'</code> <code>output_path</code> <code>Union[Path, PosixPath]</code> <p>Union[Path, PosixPath]</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Path, PosixPath, DataFrame]</code> <p>Union[Path, PosixPath, DataFrame]</p> Source code in <code>census_istat/data/manage_data.py</code> <pre><code>def merge_data(\n        csv_path: Union[Path, PosixPath],\n        year: int,\n        separator: str = ';',\n        output_path: Union[Path, PosixPath] = None,\n) -&gt; Union[Path, PosixPath, DataFrame]:\n\"\"\"Unione di tutti i dati censuari per l'anno selezionato\n    in un unico DataFrame.\n\n    Args:\n        csv_path: Union[Path, PosixPath]\n        year: int\n        separator: str\n        output_path: Union[Path, PosixPath]\n\n    Returns:\n        Union[Path, PosixPath, DataFrame]\n    \"\"\"\n    # List all csv paths\n    files_path = list(csv_path.rglob(\"*.csv\"))\n\n    data_list = []\n    for file in files_path:\n        if not file.stem == f'tracciato_{year}_sezioni':\n            data = read_csv(csv_path=file, separator=separator)\n            data_list.append(data)\n\n    # Make Dask DataFrame\n    logging.info('Make Dask DataFrame')\n    # TODO Multithread processing with Dask #15\n    # ddf = dd.concat(data_list)\n    ddf = pd.concat(data_list)\n    ddf = ddf.sort_values(f'sez{year}')\n\n    if output_path is None:\n        return ddf\n\n    else:\n        output_data = output_path.joinpath(f'data{year}.csv')\n        logging.info(f'Save data to {output_data}')\n        # TODO Multithread processing with Dask #15\n        # df = ddf.compute()\n        df = ddf\n        df.to_csv(output_data, sep=separator, index=False)\n</code></pre>"},{"location":"documentation/data/#census_istat.data.manage_data.read_csv","title":"<code>read_csv(csv_path, separator=';')</code>","text":"<p>Lettura di un csv e conversione in DataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>csv_path</code> <code>Union[Path, PosixPath]</code> <p>Union[Path, PosixPath]</p> required <code>separator</code> <code>str</code> <p>str</p> <code>';'</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame</p> Source code in <code>census_istat/data/manage_data.py</code> <pre><code>def read_csv(\n        csv_path: Union[Path, PosixPath],\n        separator: str = ';'\n) -&gt; DataFrame:\n\"\"\"Lettura di un csv e conversione in DataFrame.\n\n    Args:\n        csv_path: Union[Path, PosixPath]\n        separator: str\n\n    Returns:\n        DataFrame\n    \"\"\"\n    # Get encoding\n    logging.info('Get encoding')\n    data_encoding = check_encoding(data=csv_path)\n\n    # Read data\n    logging.info('Read data')\n    # TODO Multithread processing with Dask #15\n    # ddf = dd.read_csv(csv_path, encoding=data_encoding, sep=separator, sample=100000, assume_missing=True)\n    ddf = pd.read_csv(csv_path, encoding=data_encoding, sep=separator)\n    ddf.columns = ddf.columns.str.lower()\n    ddf = ddf.replace(['nan', 'NaN'], 0)\n\n    return ddf\n</code></pre>"},{"location":"documentation/download/","title":"Modulo Download","text":""},{"location":"documentation/download/#census_istat.download.download_administrative_boundaries","title":"<code>download_administrative_boundaries(output_data_folder, year=2011)</code>","text":"<p>Download dei limiti amministrativi dell'anno cenusario selezionato.</p> <p>Parameters:</p> Name Type Description Default <code>output_data_folder</code> <code>Union[Path, PosixPath]</code> <p>Union[Path, PosixPath]</p> required <code>year</code> <code>int</code> <p>int</p> <code>2011</code> <p>Returns:</p> Type Description <code>Union[Path, PosixPath]</code> <p>Union[Path, PosixPath]</p> Source code in <code>census_istat/download.py</code> <pre><code>def download_administrative_boundaries(\n        output_data_folder: Union[Path, PosixPath],\n        year: int = 2011\n) -&gt; Union[Path, PosixPath]:\n\"\"\"Download dei limiti amministrativi dell'anno cenusario selezionato.\n\n    Args:\n        output_data_folder: Union[Path, PosixPath]\n        year: int\n\n    Returns:\n        Union[Path, PosixPath]\n    \"\"\"\n    # Make folder for yearly census data\n    destination_folder = census_folder(output_data_folder=output_data_folder, year=year)\n\n    # Make data folder\n    data_folder = destination_folder.joinpath(BOUNDARIES_DATA_FOLDER)\n    Path(data_folder).mkdir(parents=True, exist_ok=True)\n\n    data_link = f\"{MAIN_LINK}/confini_amministrativi/non_generalizzati/Limiti{year}.zip\"\n\n    data_file_name = data_link.split('/')[-1]\n    data_file_path_dest = Path(data_folder).joinpath(data_file_name)\n\n    logging.info(\"Download administrative boundaries\")\n    _download_data(\n        data_link=data_link,\n        data_file_path_destination=data_file_path_dest,\n        data_folder=data_folder,\n        destination_folder=destination_folder\n    )\n    logging.info(\"Download administrative boundaries completed\")\n</code></pre>"},{"location":"documentation/download/#census_istat.download.download_all_census_data","title":"<code>download_all_census_data(output_data_folder, year=2011)</code>","text":"<p>Download di tutti i dati censuari per l'anno selezionato.</p> <p>Parameters:</p> Name Type Description Default <code>output_data_folder</code> <code>Union[Path, PosixPath]</code> <p>Union[Path, PosixPath]</p> required <code>year</code> <code>int</code> <p>int</p> <code>2011</code> Source code in <code>census_istat/download.py</code> <pre><code>def download_all_census_data(\n        output_data_folder: Union[Path, PosixPath],\n        year: int = 2011\n) -&gt; None:\n\"\"\"Download di tutti i dati censuari per l'anno selezionato.\n\n    Args:\n        output_data_folder: Union[Path, PosixPath]\n        year: int\n    \"\"\"\n    # Make data folder\n    data_folder = output_data_folder.joinpath(PREPROCESSING_FOLDER)\n    Path(data_folder).mkdir(parents=True, exist_ok=True)\n\n    # Download data\n    download_census_data(\n        output_data_folder=data_folder, year=year\n    )\n\n    # Download geodata\n    download_census_geodata(\n        output_data_folder=data_folder, year=year\n    )\n\n    # Download administrative boundaries\n    download_administrative_boundaries(\n        output_data_folder=data_folder, year=year\n    )\n</code></pre>"},{"location":"documentation/download/#census_istat.download.download_census_data","title":"<code>download_census_data(output_data_folder, year=2011)</code>","text":"<p>Download dei dati censuari.</p> <p>Parameters:</p> Name Type Description Default <code>output_data_folder</code> <code>Union[Path, PosixPath]</code> <p>Union[Path, PosixPath]</p> required <code>year</code> <code>int</code> <p>Integer. Default 2011.</p> <code>2011</code> <p>Returns     Union[Path, PosixPath]</p> Source code in <code>census_istat/download.py</code> <pre><code>def download_census_data(\n        output_data_folder: Union[Path, PosixPath],\n        year: int = 2011\n) -&gt; Union[Path, PosixPath]:\n\"\"\"Download dei dati censuari.\n\n    Args:\n        output_data_folder: Union[Path, PosixPath]\n        year: Integer. Default 2011.\n\n    Returns\n        Union[Path, PosixPath]\n    \"\"\"\n    # Make folder for yearly census data\n    destination_folder = census_folder(output_data_folder=output_data_folder, year=year)\n\n    # Make data folder\n    data_folder = destination_folder.joinpath('data')\n    Path(data_folder).mkdir(parents=True, exist_ok=True)\n\n    data_link = f\"{MAIN_LINK}/variabili-censuarie/dati-cpa_{year}.zip\"\n\n    data_file_name = Path(data_link).stem + Path(data_link).suffix\n    data_file_path_dest = Path(data_folder).joinpath(data_file_name)\n\n    logging.info(\"Download census data\")\n    _download_data(\n        data_link=data_link,\n        data_file_path_destination=data_file_path_dest,\n        data_folder=data_folder,\n        destination_folder=destination_folder\n    )\n\n    if year in [1991, 2001]:\n        logging.info(f'Convert xls to csv for {year}')\n        files_list = list(data_folder.rglob(\"*.xls\"))\n        first_element = files_list[0]\n\n        # Make data folder\n        data_folder_1991_2001 = data_folder.joinpath(CENSUS_DATA_FOLDER)\n        Path(data_folder_1991_2001).mkdir(parents=True, exist_ok=True)\n\n        census_trace(\n            file_path=first_element,\n            year=year,\n            output_path=data_folder_1991_2001\n        )\n        remove_xls(\n            folder_path=data_folder,\n            census_code=f'sez{year}',\n            output_path=data_folder_1991_2001,\n        )\n    logging.info(\"Download census data completed\")\n</code></pre>"},{"location":"documentation/download/#census_istat.download.download_census_geodata","title":"<code>download_census_geodata(output_data_folder, year=2011)</code>","text":"<p>Download dei geodati censuari.</p> <p>Parameters:</p> Name Type Description Default <code>output_data_folder</code> <code>Union[Path, PosixPath]</code> <p>Union[Path, PosixPath]</p> required <code>year</code> <code>int</code> <p>Integer. Default 2011.</p> <code>2011</code> <p>Returns:</p> Type Description <code>Union[Path, PosixPath]</code> <p>Union[Path, PosixPath]</p> Source code in <code>census_istat/download.py</code> <pre><code>def download_census_geodata(\n        output_data_folder: Union[Path, PosixPath],\n        year: int = 2011\n) -&gt; Union[Path, PosixPath]:\n\"\"\"Download dei geodati censuari.\n\n    Args:\n        output_data_folder: Union[Path, PosixPath]\n        year: Integer. Default 2011.\n\n    Returns:\n        Union[Path, PosixPath]\n    \"\"\"\n    # Make folder for yearly census data\n    destination_folder = census_folder(output_data_folder=output_data_folder, year=year)\n    Path(destination_folder).mkdir(parents=True, exist_ok=True)\n\n    # Make data folder\n    data_folder = destination_folder.joinpath(GEODATA_FOLDER)\n    Path(data_folder).mkdir(parents=True, exist_ok=True)\n\n    year_folder = str(year)[2:]\n    regions = tqdm(range(1, 21, 1))\n\n    logging.info(\"Download census geodata\")\n    for region in regions:\n        region = str(region).zfill(2)\n        data_link = f\"{MAIN_LINK}/basi_territoriali/WGS_84_UTM/{year}/R{region}_{year_folder}_WGS84.zip\"\n\n        data_file_name = data_link.split('/')[-1]\n        data_file_path_dest = Path(data_folder).joinpath(data_file_name)\n\n        _download_data(\n            data_link=data_link,\n            data_file_path_destination=data_file_path_dest,\n            data_folder=data_folder,\n            destination_folder=destination_folder\n        )\n\n    logging.info(\"Download census geodata completed\")\n</code></pre>"},{"location":"documentation/generic/","title":"Modulo Processi Generici","text":""},{"location":"documentation/generic/#census_istat.generic.census_folder","title":"<code>census_folder(output_data_folder, year=2011)</code>","text":"<p>Creazione delle cartelle per dati e geodati censuari dell'anno selezionato.</p> <p>Parameters:</p> Name Type Description Default <code>output_data_folder</code> <code>Union[Path, PosixPath]</code> <p>Union[Path, PosixPath]</p> required <code>year</code> <code>int</code> <p>int</p> <code>2011</code> <p>Returns:</p> Type Description <code>Union[Path, PosixPath]</code> <p>Union[Path, PosixPath]</p> Source code in <code>census_istat/generic.py</code> <pre><code>def census_folder(\n        output_data_folder: Union[Path, PosixPath],\n        year: int = 2011  # last official census at 2023 02 19\n) -&gt; Union[Path, PosixPath]:\n\"\"\"Creazione delle cartelle per dati e geodati censuari\n    dell'anno selezionato.\n\n    Args:\n        output_data_folder: Union[Path, PosixPath]\n        year: int\n\n    Returns:\n        Union[Path, PosixPath]\n    \"\"\"\n    logging.info(f\"Make folder for {year}' census data and geodata.\")\n    download_folder_name = f\"census_{year}\"\n    fs, fs_token, paths = get_fs_token_paths(output_data_folder)\n\n    destination_folder = Path(paths[0]).joinpath(download_folder_name)\n    Path(destination_folder).mkdir(parents=True, exist_ok=True)\n\n    return destination_folder\n</code></pre>"},{"location":"documentation/generic/#census_istat.generic.census_geodata_folder","title":"<code>census_geodata_folder(output_data_folder, year)</code>","text":"<p>Creazione della cartella dei geodati per l'anno censuario selezionato.</p> <p>Parameters:</p> Name Type Description Default <code>output_data_folder</code> <code>Union[Path, PosixPath]</code> <p>Union[Path, PosixPath]</p> required <code>year</code> <code>int</code> <p>int</p> required <p>Returns:</p> Type Description <code>Union[Path, PosixPath]</code> <p>Union[Path, PosixPath]</p> Source code in <code>census_istat/generic.py</code> <pre><code>def census_geodata_folder(\n        output_data_folder: Union[Path, PosixPath],\n        year: int\n) -&gt; Union[Path, PosixPath]:\n\"\"\"Creazione della cartella dei geodati per l'anno censuario selezionato.\n\n    Args:\n        output_data_folder: Union[Path, PosixPath]\n        year: int\n\n    Returns:\n        Union[Path, PosixPath]\n    \"\"\"\n    # Make folder for yearly census data\n    destination_folder = census_folder(output_data_folder=output_data_folder, year=year)\n\n    folder = destination_folder.joinpath(GEODATA_FOLDER)\n\n    return folder\n</code></pre>"},{"location":"documentation/generic/#census_istat.generic.check_encoding","title":"<code>check_encoding(data)</code>","text":"<p>Verifica della codifica del dato.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Union[Path, PosixPath]</code> <p>Union[Path, PosixPath]</p> required <p>Returns:</p> Type Description <code>str</code> <p>str</p> Source code in <code>census_istat/generic.py</code> <pre><code>def check_encoding(data: Union[Path, PosixPath]) -&gt; str:\n\"\"\"Verifica della codifica del dato.\n\n    Args:\n        data: Union[Path, PosixPath]\n\n    Returns:\n        str\n    \"\"\"\n    # Look at the first ten thousand bytes to guess the character encoding\n    with open(data, 'rb') as rawdata:\n        result = chardet.detect(rawdata.read(100000))\n\n        if result['encoding'] == 'ascii':\n            result['encoding'] = 'latin1'\n\n    return result['encoding']\n</code></pre>"},{"location":"documentation/generic/#census_istat.generic.csv_from_excel","title":"<code>csv_from_excel(data, output_path, metadata=False)</code>","text":"<p>Conversione di un xls in csv.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Union[Path, PosixPath]</code> <p>Union[Path, PosixPath]</p> required <code>output_path</code> <code>Union[Path, PosixPath]</code> <p>Union[Path, PosixPath]</p> required <code>metadata</code> <code>bool</code> <p>bool</p> <code>False</code> <p>Returns:</p> Type Description <code>Union[Path, PosixPath]</code> <p>Union[Path, PosixPath]</p> Source code in <code>census_istat/generic.py</code> <pre><code>def csv_from_excel(\n        data: Union[Path, PosixPath],\n        output_path: Union[Path, PosixPath],\n        metadata: bool = False\n) -&gt; Union[Path, PosixPath]:\n\"\"\"Conversione di un xls in csv.\n\n    Args:\n        data: Union[Path, PosixPath]\n        output_path: Union[Path, PosixPath]\n        metadata: bool\n\n    Returns:\n        Union[Path, PosixPath]\n    \"\"\"\n    logging.info(f'Read data from {data}')\n    read_data = xlrd.open_workbook(data)\n\n    if metadata:\n        sheet_name = 'Metadati'\n    else:\n        sheet_list = read_data.sheet_names()\n        sheet_list.remove('Metadati')\n        sheet_name = sheet_list[0]\n\n    get_sheet = read_data.sheet_by_name(sheet_name)\n\n    output_data = open(output_path, 'w')\n    write_csv = csv.writer(output_data, quoting=csv.QUOTE_ALL)\n\n    logging.info('Convert xls to csv')\n    for row_id in tqdm(range(get_sheet.nrows)):\n        write_csv.writerow(get_sheet.row_values(row_id))\n\n    output_data.close()\n\n    return output_path\n</code></pre>"},{"location":"documentation/generic/#census_istat.generic.get_metadata","title":"<code>get_metadata(input_path, output_path)</code>","text":"<p>Lettura dei metadati.</p> <p>Parameters:</p> Name Type Description Default <code>input_path</code> <code>Union[Path, PosixPath]</code> <p>Union[Path, PosixPath]</p> required <code>output_path</code> <code>Union[Path, PosixPath]</code> <p>Union[Path, PosixPath]</p> required <p>Returns:</p> Type Description <code>list</code> <p>list</p> Source code in <code>census_istat/generic.py</code> <pre><code>def get_metadata(input_path: Union[Path, PosixPath], output_path: Union[Path, PosixPath]) -&gt; list:\n\"\"\"Lettura dei metadati.\n\n    Args:\n        input_path: Union[Path, PosixPath]\n        output_path: Union[Path, PosixPath]\n\n    Returns:\n        list\n    \"\"\"\n    file_list = list(input_path.rglob(\"*\"))\n\n    path_list = []\n    for data_file in file_list:\n        file_name = data_file.stem.split('\\\\')[1]\n        process_data = csv_from_excel(\n            data=data_file,\n            output_path=output_path.joinpath(f'{file_name}.csv'),\n            metadata=True\n        )\n        path_list.append(process_data)\n\n    return path_list\n</code></pre>"},{"location":"documentation/generic/#census_istat.generic.unzip_data","title":"<code>unzip_data(input_data, output_folder)</code>","text":"<p>Decompressione dei dati.</p> <p>Parameters:</p> Name Type Description Default <code>input_data</code> <code>Union[Path, PosixPath]</code> <p>Union[Path, PosixPath].</p> required <code>output_folder</code> <code>Union[Path, PosixPath]</code> <p>Union[Path, PosixPath].</p> required <p>Returns:</p> Type Description <code>Union[Path, PosixPath]</code> <p>Union[Path, PosixPath]</p> Source code in <code>census_istat/generic.py</code> <pre><code>def unzip_data(input_data: Union[Path, PosixPath], output_folder: Union[Path, PosixPath]) -&gt; Union[Path, PosixPath]:\n\"\"\"Decompressione dei dati.\n\n    Args:\n        input_data: Union[Path, PosixPath].\n        output_folder: Union[Path, PosixPath].\n\n    Returns:\n        Union[Path, PosixPath]\n    \"\"\"\n    with zipfile.ZipFile(input_data, \"r\") as zf:\n        zf.extractall(output_folder)\n</code></pre>"},{"location":"documentation/geodata/","title":"Modulo GeoDati","text":""},{"location":"documentation/geodata/#census_istat.geodata.manage_geodata.join_year_census","title":"<code>join_year_census(data_path, year, remove_processed=False, only_shared=True, output_path=None)</code>","text":"<p>Generazione di un unico GeoDataFrame che unisce dati e geodati censuari per l'anno selezionato.</p> <p>Parameters:</p> Name Type Description Default <code>data_path</code> <code>Union[Path, PosixPath]</code> <p>Union[Path, PosixPath]</p> required <code>year</code> <code>int</code> <p>int</p> required <code>remove_processed</code> <code>bool</code> <p>bool</p> <code>False</code> <code>only_shared</code> <code>bool</code> <p>bool</p> <code>True</code> <code>output_path</code> <code>Union[Path, PosixPath]</code> <p>Union[Path, PosixPath]</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Path, PosixPath, GeoDataFrame]</code> <p>Union[Path, PosixPath, GeoDataFrame]</p> Source code in <code>census_istat/geodata/manage_geodata.py</code> <pre><code>def join_year_census(\n        data_path: Union[Path, PosixPath],\n        year: int,\n        remove_processed: bool = False,\n        only_shared: bool = True,\n        output_path: Union[Path, PosixPath] = None,\n) -&gt; Union[Path, PosixPath, GeoDataFrame]:\n\"\"\"Generazione di un unico GeoDataFrame che unisce dati e geodati censuari per l'anno selezionato.\n\n    Args:\n        data_path: Union[Path, PosixPath]\n        year: int\n        remove_processed: bool\n        only_shared: bool\n        output_path: Union[Path, PosixPath]\n\n    Returns:\n        Union[Path, PosixPath, GeoDataFrame]\n    \"\"\"\n    # Read data\n    data = read_csv(csv_path=data_path.joinpath(f'data{year}.csv'))\n\n    if only_shared:\n        # Filter shared columns\n        shared_data_columns = list_shared_columns()\n        administrative_columns = [f'sez{year}', 'codreg', 'regione', 'codpro', 'provincia', 'codcom', 'comune']\n        shared_columns = administrative_columns + shared_data_columns\n        data = data[shared_columns]\n\n    # Read geodata\n    geodata = read_geodata(geodata_path=data_path.joinpath(f'geodata{year}.gpkg'))\n\n    # Join all\n    logging.info('Join all')\n    df = pd.merge(\n        left=geodata,\n        right=data,\n        on=f'sez{year}',\n        how='right'\n    )\n    df = df[df['comune'].notna()]\n    df.set_index(f'sez{year}', inplace=True)\n    gdf = gpd.GeoDataFrame(df, crs=geodata.crs)\n\n    if remove_processed:\n        logging.info(f'Delete data path {data_path}')\n        shutil.rmtree(data_path)\n\n    if output_path is None:\n        return gdf\n\n    else:\n        output_data = output_path.joinpath(f'census_{year}.gpkg')\n        logging.info(f'Save data to {output_data}')\n        gdf.to_file(output_data, driver='GPKG')\n</code></pre>"},{"location":"documentation/geodata/#census_istat.geodata.manage_geodata.read_geodata","title":"<code>read_geodata(geodata_path)</code>","text":"<p>Lettura del geodato. La funzione incapsula la funzione di lettura di GeoPandas ma andr\u00e0 successivamente sviuppata per rendere pi\u00f9 rapida la lettura dei dati.</p> <p>Parameters:</p> Name Type Description Default <code>geodata_path</code> <code>Union[Path, PosixPath]</code> <p>Union[Path, PosixPath]</p> required <p>Returns:</p> Type Description <code>GeoDataFrame</code> <p>GeoDataFrame</p> Source code in <code>census_istat/geodata/manage_geodata.py</code> <pre><code>def read_geodata(\n        geodata_path: Union[Path, PosixPath],\n) -&gt; GeoDataFrame:\n\"\"\"Lettura del geodato. La funzione incapsula la funzione di lettura di\n    GeoPandas ma andr\u00e0 successivamente sviuppata per rendere pi\u00f9 rapida la\n    lettura dei dati.\n\n\n    Args:\n        geodata_path: Union[Path, PosixPath]\n\n    Returns:\n        GeoDataFrame\n    \"\"\"\n    logging.info('Read geodata')\n    gdf = gpd.read_file(geodata_path)\n\n    return gdf\n</code></pre>"},{"location":"documentation/geodata/#census_istat.geodata.manage_geodata.read_raw_census_geodata","title":"<code>read_raw_census_geodata(data_path, year, output_path=None)</code>","text":"<p>Lettura di tutti i geodati censuari grezzi per anno e creazione di un unico GeoDataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>data_path</code> <code>Union[Path, PosixPath]</code> <p>Union[Path, PosixPath]</p> required <code>year</code> <code>int</code> <p>int</p> required <code>output_path</code> <code>Union[Path, PosixPath]</code> <p>Union[Path, PosixPath]</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Path, PosixPath, GeoDataFrame]</code> <p>Union[Path, PosixPath, GeoDataFrame]</p> Source code in <code>census_istat/geodata/manage_geodata.py</code> <pre><code>def read_raw_census_geodata(\n        data_path: Union[Path, PosixPath],\n        year: int,\n        output_path: Union[Path, PosixPath] = None,\n) -&gt; Union[Path, PosixPath, GeoDataFrame]:\n\"\"\"Lettura di tutti i geodati censuari grezzi per anno e\n    creazione di un unico GeoDataFrame.\n\n    Args:\n        data_path: Union[Path, PosixPath]\n        year: int\n        output_path: Union[Path, PosixPath]\n\n    Returns:\n        Union[Path, PosixPath, GeoDataFrame]\n    \"\"\"\n    main_path = data_path.joinpath(f'census_{year}').joinpath(GEODATA_FOLDER)\n    files_list = list(main_path.rglob('*.shp'))\n\n    # List all geodata\n    logging.info('List all geodata')\n    geodata_list = []\n    data_crs = []\n    for path in tqdm(files_list):\n        geodata = read_raw_geodata(data_path=path, year=year)\n        data_crs.append(geodata.crs)\n        geodata_list.append(geodata)\n\n    # Make DataFrame\n    df = pd.concat(geodata_list)\n    df.sort_values(f'sez{year}', ascending=True, inplace=True)\n\n    # Make GeoDataFrame\n    logging.info(f'Make GeoDataFrame for {year}')\n    gdf = gpd.GeoDataFrame(df, crs=data_crs[0])\n    gdf['area_mq'] = round(gdf.geometry.area, 0)\n\n    if output_path is None:\n        return gdf\n\n    else:\n        output_data = output_path.joinpath(f'geodata{year}.gpkg')\n        logging.info(f'Save data to {output_data}')\n        gdf.to_file(output_data, driver='GPKG')\n</code></pre>"},{"location":"documentation/geodata/#census_istat.geodata.manage_geodata.read_raw_geodata","title":"<code>read_raw_geodata(data_path, year)</code>","text":"<p>Lettura del singolo geodato censuario grezzo e pulizia topologica delle geometrie.</p> <p>Parameters:</p> Name Type Description Default <code>data_path</code> <code>Union[Path, PosixPath]</code> <p>Union[Path, PosixPath]</p> required <code>year</code> <code>int</code> <p>int</p> required <p>Returns:</p> Type Description <code>GeoDataFrame</code> <p>GeoDataFrame</p> Source code in <code>census_istat/geodata/manage_geodata.py</code> <pre><code>def read_raw_geodata(\n        data_path: Union[Path, PosixPath],\n        year: int,\n) -&gt; GeoDataFrame:\n\"\"\"Lettura del singolo geodato censuario grezzo e pulizia topologica delle geometrie.\n\n    Args:\n        data_path: Union[Path, PosixPath]\n        year: int\n\n    Returns:\n        GeoDataFrame\n    \"\"\"\n    read_data = gpd.read_file(data_path)\n    read_data = read_data[[f'SEZ{year}', 'TIPO_LOC', 'geometry']]\n\n    data_list = []\n    for index, row in tqdm(read_data.iterrows()):\n        if row[f'SEZ{year}'] != 0:\n            census_cell_tipe = TIPO_LOC[year][row['TIPO_LOC']]\n            census_cell_code = int(row[f'SEZ{year}'])\n            census_cell_geometry = make_valid(row['geometry'])\n            data = [census_cell_code, census_cell_tipe, census_cell_geometry]\n            data_list.append(data)\n\n    df = pd.DataFrame(data_list, columns=[f'sez{year}', 'tipo_loc', 'geometry'])\n    df.sort_values(f'sez{year}', ascending=True, inplace=True)\n    gdf = gpd.GeoDataFrame(df, crs=read_data.crs)\n\n    return gdf\n</code></pre>"},{"location":"documentation/intro/","title":"Documentazione","text":"<p>Le funzioni sviluppate consentono di gestire sia i dati che i geodati censuari nella loro interezza. \u00c8 possibile infatti effettuare il download del dato e del geodato e successivamente processarlo.</p>"},{"location":"tutorial/intro/","title":"Tutorial","text":"<p>Coming soon...</p>"},{"location":"tutorial/test/","title":"Tutorial","text":"(function() {   function addWidgetsRenderer() {     var requireJsScript = document.createElement('script');     requireJsScript.src = 'https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js';      var mimeElement = document.querySelector('script[type=\"application/vnd.jupyter.widget-view+json\"]');     var jupyterWidgetsScript = document.createElement('script');     var widgetRendererSrc = 'https://unpkg.com/@jupyter-widgets/html-manager@*/dist/embed-amd.js';     var widgetState;      // Fallback for older version:     try {       widgetState = mimeElement &amp;&amp; JSON.parse(mimeElement.innerHTML);        if (widgetState &amp;&amp; (widgetState.version_major &lt; 2 || !widgetState.version_major)) {         widgetRendererSrc = 'jupyter-js-widgets@*/dist/embed.js';       }     } catch(e) {}      jupyterWidgetsScript.src = widgetRendererSrc;      document.body.appendChild(requireJsScript);     document.body.appendChild(jupyterWidgetsScript);   }    document.addEventListener('DOMContentLoaded', addWidgetsRenderer); }());  <pre><code>txt = 'Coming soon!'\ntxt\n</code></pre> <pre>\n<code>'Coming soon!'</code>\n</pre>"}]}